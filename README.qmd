---
execute: 
  cache: true
  echo: false
  message: false
  warning: false
format: gfm
# For sharing interactive results:
# format:
#   html:
#     embed-resources: true
---

```{bash}
#| eval: false
# rename interactive version of html to severance.html
cp README.html severance.html
gh release upload v1.0 severance.html --clobber
# see https://github.com/acteng/severance/releases/tag/v1.0/severance.html
```

# Calculating active travel potential and severance around major transport infrastructure

Note: an interactive version of this report is available [here](https://acteng.github.io/severance/severance.html).

```{r}
#| include: false
library(tidyverse)
library(terra)
library(tmap)
```

```{r}
#| eval: false
#| echo: false
remotes::install_github("robinlovelace/styler.equals")
remotes::install_dev("tmap")
```

This repo builds on work documented in the [srn](https://github.com/acteng/srn) repo, focussing on active travel potential and severance around major transport infrastructure.

# Input datasets

## Road network data

The Strategic Road Network (SRN) and Major Road Network (MRN) are illustrated below (source: [browse tool of ATIP](https://acteng.github.io/atip/browse.html?style=dataviz#6.2/52.917/-1.327)).

![](images/paste-1.png)


```{r}
#| label: dl-mrn
#| include: false
if (!file.exists("mrn.gpkg")) {
  message("Missing the MRN dataset locally, download it from the DfT or releases")
  u = "https://maps.dft.gov.uk/major-road-network-shapefile/Major_Road_Network_2018_Open_Roads.zip"
  f = basename(u)
  if (!file.exists(f)) download.file(u, f)
  unzip(f)
  mrn = sf::read_sf("Major_Road_Network_2018_Open_Roads.shp")
  names(mrn)
  #  [1] "fid_"       "id"         "endNode"    "startNode"  "roadNumber"
  #  [6] "roadNameTO" "fictitious" "roadClassi" "roadFuncti" "formOfWay"
  # [11] "length"     "length_uom" "loop"       "primaryRou" "trunkRoad"
  # [16] "roadClas_1" "name1"      "name1_lang" "name2"      "name2_lang"
  # [21] "roadStruct" "geom_Lengt" "identifier" "geom"
  mrn = mrn |>
    transmute(
      name = name1,
      road_function = roadFuncti,
      form_of_way = formOfWay,
      road_classification = roadClassi,
      infrastructure_type = "MRN"
    )
  sf::st_write(mrn, "mrn.gpkg", delete_dsn = TRUE)
  # Release data:
  if (FASLE) {
    # system("gh release create v1.0 mrn.gpkg")
    # Re-upload with clobber
    system("gh release upload v1.0 mrn.gpkg --clobber")
  }
}
mrn = sf::read_sf("mrn.gpkg")
```

```{r}
#| label: dl-srn
#| include: false
if (!file.exists("srn.gpkg")) {
  message("Missing the SRN dataset locally, download it from the DfT or releases")
  u = "https://api.os.uk/downloads/v1/products/OpenRoads/downloads?area=GB&format=GeoPackage&redirect"
  f = "oproad_gpkg_gb.zip"
  if (!file.exists(f)) download.file(u, f)
  unzip(f)
  list.files("Data")
  # See https://github.com/acteng/atip-data-prep/blob/d2a5d0058932a00e0130048cf407448f4b75a477/layers/srn.py#L6
  # for filter:             "SELECT name_1 as name, geometry FROM road_link WHERE trunk_road"
  # q = "SELECT name_1 as name, geometry FROM road_link WHERE trunk_road"
  # srn = sf::read_sf("Data/oproad_gb.gpkg", query = q) # failed:
  open_roads_national = sf::read_sf("Data/oproad_gb.gpkg", layer = "road_link")
  names(open_roads_national)
  head(table(open_roads_national$road_classification_number))
  #    [1] "id"                         "fictitious"
  #  [3] "road_classification"        "road_function"
  #  [5] "form_of_way"                "road_classification_number"
  #  [7] "name_1"                     "name_1_lang"
  #  [9] "name_2"                     "name_2_lang"
  # [11] "road_structure"             "length"
  # [13] "length_uom"                 "loop"
  # [15] "primary_route"              "trunk_road"
  # [17] "start_node"                 "end_node"
  # [19] "road_number_toid"           "road_name_toid"
  # [21] "geometry"
  table(open_roads_national$trunk_road)
  srn = open_roads_national |>
    filter(trunk_road) |>
    transmute(
      id,
      name = name_1,
      road_function = road_function,
      form_of_way = form_of_way,
      road_classification = road_classification,
      road_classification_number = road_classification_number,
      infrastructure_type = "SRN"
    )
  sf::write_sf(srn, "srn.gpkg", delete_dsn = TRUE)
  # Release data:
  if (FALSE) {
    system("gh release upload v1.0 srn.gpkg --clobber")
  }
}
srn = sf::read_sf("srn.gpkg")
# names(srn)
```

After downloading and combining the datasets, we can plot them as follows with R:

```{r}
#| label: combine-srn-mrn
#| include: false
mrn_srn = rbind(
  mrn,
  srn |> transmute(
    name = name,
    road_function = road_function,
    form_of_way = form_of_way,
    road_classification = road_classification,
    infrastructure_type = "SRN"
  )
)
# mrn_srn |>
#   ggplot() +
#   geom_sf(aes(color = infrastructure_type)) +
#   theme_void() 
names(mrn_srn)
mrn |>
  tm_shape() +
  tm_lines(col = "grey") +
  tm_shape(srn) +
  tm_lines() +
  tm_title("SRN (black) and MRN (grey)", just = c("center", "top"))
```

The main focus of the analysis presented in this report is the SRN, the road network controlled by National Highways (NH).

## Propensity to cycle tool

Data on active travel potential was taken from the Propensity to Cycle Tool (PCT), a Department for Transport funded project that builds on official data to model cycling potential nationwide.
In future we would like to add data representing walking potential, possibly based on travel to school data.

# Active travel potential

As a first approximation of active travel potential we used Propensity to Cycle Tool (PCT) data.
To ensure consistency across areas, we defined 'cycling potential' in this case as the distance that could be cycled *within* each grid cell, reducing the influence of variable road lengths on the results (10 100 m segments with cycling potential of 20 has the same impact as a single 5 km segment with cycling potential of 20 trips per day).
Aggregating to 5 km resolution ensures the operations work fast for national data and remove noise from the results.
Higher levels of spatial resolution could be used in future work.

```{r}
#| label: dl-pct
if (!file.exists("pct.gpkg")) {
  remotes::install_cran("pct")
  pct_rnet = pct::get_pct(layer = "rnet", national = TRUE)
  pct_projected = pct_rnet |>
    sf::st_transform(27700)
  pct_projected$segment_length_km = sf::st_length(pct_projected) / 1000 |>
    as.numeric()
  pct_projected = pct_projected |>
    mutate(
      cycling_km_baseline = bicycle * segment_length_km,
      cycling_km_go_dutch = dutch_slc * segment_length_km
    )
  sf::write_sf(pct_projected, "pct.gpkg", delete_dsn = TRUE)
}
pct = sf::read_sf("pct.gpkg")
```

<!-- We'll convert the pct linestring data to a 5 km raster grid with the {terra} package. -->

```{r}
#| label: pct-raster
#| layout-ncol: 2
pct_raster = terra::rast(pct, res = 5000)
# ?rasterize
pct_raster_baseline = terra::rasterize(pct, pct_raster, field = "cycling_km_baseline", fun = sum)
pct_raster_go_dutch = terra::rasterize(pct, pct_raster, field = "cycling_km_go_dutch", fun = sum)
# par(mfrow = c(1, 2))
# plot(pct_raster_baseline, type = "interval", breaks = c(0, 1, 2, 5, 10, 20, 100)*1000)
# plot(pct_raster_go_dutch, type = "interval", breaks = c(0, 1, 2, 5, 10, 20, 100)*1000)
# par(mfrow = c(1, 1))
brks = c(0, 1, 5, 10, 20, 100)*1000
m1 = tm_shape(pct_raster_baseline) +
  tm_raster("cycling_km_baseline", palette = "viridis", breaks = brks, title = "Baseline (km/day)")
m2 = tm_shape(pct_raster_go_dutch) +
  tm_raster("cycling_km_go_dutch", palette = "viridis", breaks = brks, title = "Go Dutch (km/day)")
tmap_arrange(m1, m2)
```

<!-- We can subset all grids with high cycling potential (e.g. 5000 km cycling potential) and extract nearby roads to calculate severance as follows: -->
This approach allows identification of sections of the SRN and MRN in areas with high (more than 5000 km cycled within each 5km grid cell under the Go Dutch scenario) active travel potential nationwide, as illustrated below.

```{r}
#| cache: false
if (!file.exists("pct_raster_sf.gpkg")) {


pct_raster_sf_baseline = pct_raster_baseline |>
  terra::as.points() |>
  sf::st_as_sf()
pct_raster_sf_go_dutch = pct_raster_go_dutch |>
  terra::as.points() |>
  sf::st_as_sf()
pct_raster_sf = sf::st_sf(
  data.frame(
    cycling_km_baseline = pct_raster_sf_baseline$cycling_km_baseline,
    cycling_km_go_dutch = pct_raster_sf_go_dutch$cycling_km_go_dutch,
    geometry = pct_raster_sf_baseline$geometry
  )
)
sf::st_write(pct_raster_sf, "pct_raster_sf.gpkg", delete_dsn = TRUE)
}
pct_raster_sf = sf::read_sf("pct_raster_sf.gpkg")

```

```{r}
#| label: severance
pct_high_potential_points = pct_raster_sf |>
  filter(cycling_km_go_dutch > 5000)
pct_high_buffer = pct_high_potential_points |>
  sf::st_buffer(5000) |>
  sf::st_union() 
if (!file.exists("mrn_srn_high.gpkg")) {
mrn_srn_high = mrn_srn[pct_high_buffer, ]
sf::write_sf(mrn_srn_high, "mrn_srn_high.gpkg", delete_dsn = TRUE)
}
mrn_srn_high = sf::read_sf("mrn_srn_high.gpkg")
tm_shape(mrn_srn) +
  tm_lines(col = "grey") +
  tm_shape(mrn_srn_high) +
  tm_lines(col = "infrastructure_type")
```

<!-- Building on the simplistic approach, we'll assign active travel potential to each road segment based on the values of the 'active travel potential cells' that they intersect with. -->
<!-- This approach is illustrated below (a logical extension of this approach would be to use PCT section centroids as the basis for road active travel potential values): -->
The approach also allows estimation of current and potential future levels of cycling *for every road segment*.
The results of joining the current estimated and potential cycling values to road segments, taking the mean values of cell centroids that are within 5km of each road segment centroid, are shown below.

```{r}
srn_buffer = srn |>
  sf::st_buffer(5000) |>
  sf::st_union()
pct_centroids_near = pct_raster_sf[srn_buffer, ]
# pct_centroids_near |>
#   tm_shape() +
#   tm_dots("cycling_km_go_dutch", palette = "viridis", breaks = brks, title = "Go Dutch (km/day)")
# centroids for speed of calculation:
srn$length_m = sf::st_length(srn) |> as.numeric()
# summary(srn$length_m)
#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
#     0.02    45.42   142.10   388.39   405.19 19085.20 
srn_centroids = sf::st_centroid(srn)
srn_distances = sf::st_join(
  srn_centroids,
  pct_centroids_near,
  join = sf::st_is_within_distance,
  dist = 5000
)
# summary(duplicated(srn_distances$name))
srn_distances_aggregated = srn_distances |>
  sf::st_drop_geometry() |>
  group_by(id) |>
  summarise(
    Baseline = mean(cycling_km_baseline, na.rm = TRUE),
    Potential = mean(cycling_km_go_dutch, na.rm = TRUE),
    .groups = "drop"
  )
srn_joined = left_join(srn, srn_distances_aggregated, by = "id")

tm_shape(srn_joined) +
  tm_lines(col = c(
    "Baseline",
    "Potential"
  ),
  title = "Go Dutch (km/day)",
  col.scale = tm_scale(breaks = brks, values = "viridis")
)
```

Note: the units of the values presented above are in estimated km cycling per day per 5 km grid cell, derived from the route network layer in the PCT, representing active travel potential for utility cycling in the vicinity of roads (estimated commuter cycling potential is a function of number of cyclable trips to work and is a good proxy for utility cycling potential and to a lesser extent leisure cycling potential).
We assign more meaningful units of estimated number of potential trips in the next section.

After classifying the roads into named groups and keeping only road sections with a level of cycling potential above a certain threshold (2000 km cycled within each 5 km grid cell in the first instance), we filtered out the top n. (e.g. 500) road sections based on cycling potential.
Roads were grouped in the following ways:

- by road classification number and name (if available)
- by active travel potential quantile (currently set to 20 quantiles although this can be varied to increase or decrease the number of groups and average length of road sections in each group)

In cases where the same road (e.g. M56) has multiple sections with high cycling potential, the sections are given an id, e.g. M56 1, M56 2 etc.

```{r}
#| include: false
summary(sf::st_length(srn_joined))
    # Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
    # 0.02    45.42   142.10   388.39   405.19 19085.20 
summary(srn_joined$Baseline)
  #  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
  #   0.0   715.7  2445.1  5009.3  7171.3 50691.6   11102 
srn_filtered = srn_joined |>
  # filter(length_m > 200) |>
  filter(Potential > 2000) |>
  # Create categorical variable with cycling potential split into 10 categories:
  # filter(!is.na(name))
  # Quantiles of cycling potential:
  mutate(Potential_quantile = cut(Potential, breaks = quantile(Potential, probs = seq(0, 1, 0.05), na.rm = TRUE), include.lowest = TRUE, labels = FALSE)) 
summary(srn_filtered$Potential_quantile)
srn_filtered$group = stplanr::rnet_group(srn_filtered)
# srn_filtered$group_fast = stplanr::rnet_group(srn_filtered, igraph::cluster_fast_greedy)
# walktrap grouping:
# srn_filtered$group_walktrap = stplanr::rnet_group(srn_filtered, igraph::cluster_walktrap)
# summary(srn_filtered$group_walktrap)
srn_grouped = srn_filtered |>
  # mutate(Name = paste(road_classification_number, name, group_walktrap, sep = " ")) |>
  mutate(Name = paste(road_classification_number, ifelse(is.na(name), "", name), group, Potential_quantile, sep = " ")) |>
   # group_by(name, road_classification_number, road_function, form_of_way, road_classification) |>
  group_by(Name) |>
  summarise(
    Baseline = mean(Baseline, na.rm = TRUE),
    Potential = mean(Potential, na.rm = TRUE),
    segment_length = round(sum(length_m)),
    name = first(name),
    road_classification_number = first(road_classification_number),
    .groups = "drop"
  ) |>
  group_by(name, road_classification_number) |>
  arrange(desc(Potential)) |>
  mutate(id = as.character(row_number())) |>
  # Update id so that it's "" if there's only 1 in that group:
  mutate(
    id = case_when(
      n() == 1 ~ "",
      TRUE ~ id
    )
  ) |>
  mutate(Name = paste(road_classification_number, ifelse(is.na(name), "", name), id, sep = " ")) |>
  # Remove whitespace before and after Name:
  mutate(Name = trimws(Name)) |>
  filter(segment_length > 1000) |> 
  # replace double space with single space:
  mutate(Name = gsub("  ", " ", Name)) |>
  ungroup() |>
  arrange(desc(Potential)) |>
  # Round all numeric cols:
  mutate(across(where(is.numeric), round))
head(srn_grouped$Name)  


srn_grouped_top = srn_grouped |>
  head(500) |>
  # Again, remove id if there's only 1 in that group:
  group_by(name, road_classification_number) |>
  mutate(id = as.character(row_number())) |>
  mutate(
    id = case_when(
      n() == 1 ~ "",
      TRUE ~ id
    )
  ) |>
  mutate(Name = paste(road_classification_number, ifelse(is.na(name), "", name), id, sep = " ")) |>
  # Remove whitespace before and after Name:
  mutate(Name = trimws(Name)) |>
  # replace double space with single space:
  mutate(Name = gsub("  ", " ", Name)) |>
  ungroup() |>
  arrange(desc(Potential))
head(srn_grouped_top$Name)
# |>
  # sf::st_cast("LINESTRING")
```

In total, `r nrow(srn_grouped)` road sections at least 1km in length (another parameter that can be adjusted) were identified with high cycling potential, with the top 500 shown in the interactive table below.


```{r}
#| label: top-roads
# look at roads with greatest length
# srn_grouped |>
#   arrange(desc(segment_length)) |>
#   select(name, segment_length) |>
#   head(10)

# srn_grouped_top |>
#   select(Name, Potential, segment_length) |>
#   sf::st_drop_geometry() |>
#   knitr::kable()

# interactive version of table:
library(DT)
datatable(srn_grouped_top |>
  transmute(Name, Baseline, Potential, `Length km` = round(segment_length / 1000, 1)) |>
  sf::st_drop_geometry())

# Split the SRN:

# summary(duplicated(srn_top$name))
pvars = c("Name", "Potential", "segment_length") 
m_top_srn = tm_shape(srn_filtered) +
  tm_lines(col = "darkgrey", lwd = 4) +
  tm_shape(srn_grouped_top) +
  tm_lines(col = "Potential", title = "Go Dutch (km/day)", lwd = 8, popup.vars = pvars, col.scale = tm_scale(breaks = c(10, 15, 25, 50) * 1000, values = "viridis"))
# m_top_srn
tmap_save(m_top_srn, "m_top_srn.html")
system("gh release upload v1.0 m_top_srn.html --clobber")
```

The interactive map can be viewed by downloading resulting [file](https://github.com/acteng/severance/releases/download/v1.0/m_top_srn.html)

and below:

```{r}
#| label: m_top_srn
webshot2::webshot("m_top_srn.html")
# tmap_mode("view")
# m_top_srn
```


```{r}
#| eval: false
browseURL("m_top_srn.html")
```

# Desire lines approach

```{r}
# include: false
if (!file.exists("pct_desire_lines.gpkg")) {
pct_desire_lines = pct::get_pct(layer = "l", national = TRUE)
sf::st_crs(pct_desire_lines) = 4326
sf::write_sf(pct_desire_lines, "pct_desire_lines.gpkg", delete_dsn = TRUE)
system("gh release upload v1.0 pct_desire_lines.gpkg --clobber")
if(!file.exists("pct_desire_lines.gpkg")) {
  message("Download the desire lines data from the releases")
  stop()
}
}
pct_desire_lines = sf::read_sf("pct_desire_lines.gpkg")
# dim(pct_desire_lines)
# [1] 1408275     146
# names(pct_desire_lines)
#   [1] "id"                      "geo_code1"              
#   [3] "geo_code2"               "geo_name1"              
#   [5] "geo_name2"               "lad11cd1"               
#   [7] "lad11cd2"                "lad_name1"              
#   [9] "lad_name2"               "all"                    
#  [11] "bicycle"                 "foot"                   
#  [13] "car_driver"              "car_passenger"          
#  [15] "motorbike"               "train_tube"             
#  [17] "bus"                     "taxi_other"             
#  [19] "govtarget_slc"           "govtarget_sic"          
#  [21] "govtarget_slw"           "govtarget_siw"          
#  [23] "govtarget_sld"           "govtarget_sid"          
#  [25] "govtarget_slp"           "govtarget_sip"          
#  [27] "govtarget_slm"           "govtarget_sim"          
#  [29] "govtarget_slpt"          "govtarget_sipt"         
#  [31] "govnearmkt_slc"          "govnearmkt_sic" 
#  ...
#  [127] "gendereq_sicarkm"        "gendereq_sico2"         
# [129] "dutch_sicarkm"           "dutch_sico2"            
# [131] "ebike_sicarkm"           "ebike_sico2"            
# [133] "e_dist_km"               "rf_dist_km"             
# [135] "rq_dist_km"              "dist_rf_e"              
# [137] "dist_rq_rf"              "rf_avslope_perc"        
# [139] "rq_avslope_perc"         "rf_time_min"            
# [141] "rq_time_min"             "geom"  

```

The results presented in the previous section are based on estimates of active travel (commuter cycling) potential at the road network level in the vicinity (around 5 km) of each road segment.
This approach is good for a 'first pass' national analysis but has limitations:

- There is no guarantee that the active travel on the segments in the vicinity of the roads need to interact with the roads, e.g. they could just run parallel to them.
- The approach leads to estimates of cycling potential in units that are not conducive to benefits estimation.
- The approach does not take into account the desire lines of cyclists, which may not follow the road network.

Using origin-destination data, which can be represented as 'desire lines' between origin and destination points or zones, can address these limitations.

The desire lines approach scales nationally although is more computationally intensive than the road network approach.
There are `r nrow(pct_desire_lines) |> format(big.mark = ",")`  desire lines in the national dataset from the PCT (compared with `r nrow(pct) |> format(big.mark = ",")` road segments).
An overview of the desire lines, based on a sample of the top 10,000 desire lines longer than 5km by current active travel mode share, is shown below.

```{r}
#| label: national-desire-lines-map
pct_desire_lines = pct_desire_lines |>
  mutate(
    `% cycling` = bicycle / all,
    `% walking` = foot / all,
    `% car` = (car_driver + car_passenger) / all,
    `% active` = (`% cycling` + `% walking`) 
  ) |>
  # multiply all cols starting with % by 100:
  mutate(across(starts_with("%"), ~ round(. * 100, 1))) 
# summary(pct_desire_lines$`% active`)
brks_active = c(0, 2, 5, 10, 100)
pct_desire_lines |>
  # Only those of more than 5 km in length:
  filter(e_dist_km > 5) |>
  slice_max(all, n = 10000) |>
  arrange(`% active`) |>
  tm_shape() +
  tm_lines(
    col = c("% walking", "% cycling", "% active", "% car"),
    title = "% Active Travel",
    tm_scale(breaks = brks_active, values = "viridis"),
    col.legend = tm_legend(position = tm_pos_out())
    ) +
  tm_facets_wrap(ncols = 4)
```

Because of the computational resources needed to process the national desire lines dataset, we'll focus on case study areas in this section.
The ~20k desire lines in the Manchester area are shown below.

```{r}
dl_mcr = pct_desire_lines |>
  filter(str_detect(lad_name1, "Manchester")) |>
  arrange(`% active`) 
```

```{r}
srn_wgs = sf::st_transform(srn, 4326)
sf::st_crs(dl_mcr) = 4326
srn_mcr = srn_wgs[dl_mcr, ]
```

```{r}

dl_mcr |>
  filter(all > 5) |>
  tm_shape() +
  tm_lines(
    col = c("% active"),
    title = "% Active Travel",
    tm_scale(breaks = brks_active, values = "viridis"),
    col.legend = tm_legend(position = tm_pos_out())
    ) +
  tm_shape(srn_mcr) +
  tm_lines(col = "road_classification_number", lwd = 5) +
  tm_scale_bar() 

```


<!-- # Outakes -->


```{r}
#| eval: false
# failed attempt to split the lines (fails as they require LINESTRING geometry type input)

srn_grouped |>
  sf::st_geometry_type() |>
  table()
srn_grouped_linestring = srn_grouped |>
  sf::st_line_merge()
srn_grouped_linestring |>
  sf::st_geometry_type() |>
  table()
# srn_grouped_linestring |>
#   sf::st_cast("LINESTRING") |>
#   select(Name) |>
#   plot()
?st_cast
# srn_grouped_split = srn_top_split = stplanr::line_segment(srn_grouped_linestring, segment_length = 1000, use_rsgeo = FALSE)
# nrow(srn_grouped_split) # 1414
srn_grouped_split$id_km = formatC(seq(nrow(srn_grouped_split)), flag = "00", width = 4)
head(srn_grouped_split$id_km)
srn_grouped_split = srn_grouped_split |>
  mutate(Name = paste(Name, id_km))
```

```{r}
#| eval: false
m1 = srn_grouped |>
  tm_shape() +
  tm_lines(col = "Name", legend = FALSE)
m2 = srn_grouped_split |>
  tm_shape() +
  tm_lines(col = "Name", legend = FALSE)
tmap_arrange(m1, m2)  


```


<!-- ## Breaking-up SRN into small sections -->


```{r}
#| eval: false
srn_split = stplanr::line_segment(srn, segment_length = 1000)
srn_split = stplanr::line_segment(srn, segment_length = 1000, use_rsgeo = FALSE)
nrow(srn) / nrow(srn_split)

summary(sf::st_length(srn_split))
summary(sf::st_length(srn))
plot(srn_split$geometry)

# TODO: use this as an input
sf::st_write(srn_split, "srn_split.gpkg", delete_dsn = TRUE)
system("gh release upload v1.0 srn_split.gpkg --clobber")
```


<!-- ## Demo PCT modelling: -->


```{r}
#| eval: false
pct_desire_lines$pct_desire_lines_computed = pct::uptake_pct_godutch_2020(
  distance = pct_desire_lines$rf_dist_km,
  gradient = pct_desire_lines$rf_avslope_perc
)
pct_desire_lines = pct_desire_lines |>
  
# correlation between computed and observed:
cor(pct_desire_lines$pct_desire_lines_computed, pct_desire_lines$dutch_slc / pct_desire_lines$all)
pct_desire_lines |>
  sample_n(10000) |>
  ggplot(aes(rf_dist_km, dutch_slc / all)) +
  geom_point() +
  geom_smooth() 
pct_desire_lines_high 
```